# nullable

- nullability is known as the billion dollar mistake :-)
- modern approach: runtime error --> compile time error
- nullable types and non-nullable types
  - Kotlin adds @NotNull or @Nullable under the hood
  - nullable type is indicated by the `?` character
    - e.g. `Int?`
  - `val s1: String = "always not null"`
  - `val s2: String = null` won't compile
  - but you can do: `val s2: String? = null` 
  - `s2.length` will not compile, because compiler knows that s2 is possibly null
    - so how do you check the length of s2?
    - wrap it in an if statement: `if (s2 != null) { s.length }`
    - use the safe access expression `?.` 
      - e.g. `s2?.length`
      - the result is an object of type `Int?`
      - the result will contain null when s2 itself was null
- elvis operator `?:`
  - helps to return an alternative result when something was null
  - `s?.length ?: 0`
  - `foo ?: bar`
  - origin: Groovy language
  - notice operator precedence: `x ?: 0 + y` is like `x ?: (0 + y)` because `+` and `-` has higher precedence than `?:`
- NullPointerException
  - you can explicitely throw it with `!!`
  - afterwards, the value is smart-cast to a nun-nullable type
  - `foo!!` throws a NPE if foo was null, or changes foo into a non nullable type otherwise
  - after `s!!` you can call `s.length` instead of `s?.length`
  - use case: when the compiler can't know, but you do know it's not null, and you want to get rid of the nullable type
- Optional
  - is a different approach to mitigate nullability
  - is a wrapper around an object
- lists
  - `List<Int?>` is a list of nullable Ints
  - `List<Int>?` is a nullable list that contains Ints
- extension functions on nullable receivers
  - `fun String?.isEmptyOrNull(): Boolean`
  - this way, you can call a function on an object that is null :-)
    - remember that under the hood, extension functions are just wrappers that take the receiver as a 1st argument
  - can be confusing to the readers